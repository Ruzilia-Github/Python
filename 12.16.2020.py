# n1 = input()
# n2 = input()
# if 'a' in n1 or 'c' in n1 or'e' in n1 or'g' in n1:
#     if '1' in n1 or '3' in n1 or'5' in n1 or'7' in n1:
#        n1 = False
#     else:
#        n1 = True
# elif 'b' in n1 or 'd' in n1 or'f' in n1 or'h' in n1:
#     if '2' in n1 or '4' in n1 or'6' in n1 or'8' in n1:
#        n1 = False
#     else:
#        n1 = True
# if 'a' in n2 or 'c' in n2 or 'e' in n2 or 'g' in n2:
#     if '1' in n2 or '3' in n2 or '5' in n2 or '7' in n2:
#         n2 = False
#     else:
#         n2 = True
# elif 'b' in n2 or 'd' in n2 or 'f' in n2 or 'h' in n2:
#     if '2' in n2 or '4' in n2 or '6' in n2 or '8' in n2:
#         n2 = False
#     else:
#         n2 = True
# if n1==n2:
#     print("YES")
# else:
#     print('NO')

# ____________________________________________________________________
# Напишите программу, которая определяет, оканчивается ли год с данным номером на два нуля. Если год оканчивается, то выведите «YES», иначе выведите «NO».
#
# Sample Input 1:
#
# 2000
# Sample Output 1:
#
# YES
# Sample Input 2:
#
# 1999
# Sample Output 2:
#
# NO


#
# n = int(input())
# # print(n%10)
# # print(n//10%10)
# if n%10 == 0  and n//10%10 == 0:
#     print("YES")
# else:
#     print("NO")
#
# ___________________________________________________________________

# Заданы две клетки шахматной доски. Напишите программу, которая определяет имеют ли указанные клетки один цвет или нет. Если они покрашены в один цвет, то выведите слово «YES», а если в разные цвета — то «NO».
#
# Формат входных данных
# На вход программе подаётся четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки.

# Sample Input 1:
#
# 1
# 1
# 2
# 6
# Sample Output 1:
#
# YES


# n1 = int(input())
# n2 = int(input())
# b1 = int(input())
# b2 = int(input())
# a = ''
# b = ''
# if n1 == 1 or n1 == 3 or n1 == 5 or n1 == 7:
#     if n2 == 1 or n2 == 3 or n2 == 5 or n2 == 7:
#        a = "white"
#     else:
#        a = "black"
# elif n1 == 2 or n1 == 4 or n1 == 6 or n1 == 8:
#     if n2 == 2 or n2 == 4 or n2 == 6 or n2 == 8:
#        a = "white"
#     else:
#        a = "black"
# if b1 == 1 or b1 == 3 or b1 == 5 or b1 == 7:
#     if b2 == 1 or b2 == 3 or b2 == 5 or b2 == 7:
#        b = "white"
#     else:
#        b = "black"
# elif b1 == 2 or b1 == 4 or b1 == 6 or b1 == 8:
#     if b2 == 2 or b2 == 4 or b2 == 6 or b2 == 8:
#        b = "white"
#     else:
#        b = "black"
# if a == b:
#     print("YES")
# else:
#     print('NO')

# _________________________________________________
# Футбольная команда набирает девочек от 10 до 15 лет включительно. Напишите программу, которая запрашивает возраст и пол претендента, используя обозначение пола буквы m (от male – мужчина) и f (от female – женщина) и определяет подходит ли претендент для вступления в команду или нет. Если претендент подходит, то выведите «YES», иначе выведите «NO».
#
# Формат входных данных
# На вход программе подаётся натуральное число – возраст претендента и буква обозначающая пол m (мужчина) или f (женщина).

# a = int(input())
# b = input()
# if 10 <= a <= 15  and b == "f":
#     print('YES')
# else:
#     print("NO")


# _________________________________________________________
# Напишите программу, которая считывает целое число и выводит соответствующую ему римскую цифру. Если число находится вне диапазона 1-10, то программа должна вывести текст «ошибка».
#
# В таблице приведены римские цифры для чисел от 1 до 10.

# n = int(input())
# a = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X']
# if 1 <= n <=10:
#     print(a[n-1])
# else:
#     print("ошибка")

# _______________________________________________________

# если число нечётное, то вывести «YES»;
# если число чётное в диапазоне от 2 до 5 (включительно), то вывести «NO»;
# если число чётное в диапазоне от 6 до 20 (включительно), то вывести «YES»;
# если число чётное и больше 20, то вывести «NO».

# n = int(input())
# if n%2 != 0:
#    print("YES")
# elif n%2 == 0:
#     if 2 <= n <= 5:
#        print("NO")
#     elif 6 <= n <= 20:
#        print("YES")
#     elif n > 20:
#        print("NO")


# ____________________________________________________________
#
# Даны две различные клетки шахматной доски. Напишите программу,  которая определяет, может ли конь попасть с первой клетки на вторую одним ходом. Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки. Программа должна вывести «YES», если из первой клетки ходом коня можно попасть во вторую или «NO» в противном случае.
#
# Формат входных данных
# На вход программе подаётся четыре числа от 1 до 8.
#
# x1 = int(input())
# y1 = int(input())
# x2 = int(input())
# y2 = int(input())
#
# if abs(x1 - x2) == 1 and abs(y1 - y2) == 2:
#     print('YES')
# elif abs(x1 - x2) == 2 and abs(y1 - y2) == 1:
#     print('YES')
# else:
#     print("NO")

# _________________________________________
#
# Программа принимает на вход три символа через пробел в одну строку. Необходимо вывести код каждого символа при помощи функции ord в определенном формате.


# a, c, b =map(str,input().split())
# print(f'Simvol code {a} is {ord(a)}.')
# print(f'Simvol code {c} is {ord(c)}.')
# print(f'Simvol code {b} is {ord(b)}.')

# ________________________________________________
#
# Напишите программу, которая считывает целое число, и затем сообщает какие числа будут следующим и предыдущим в определенном формате. Пробелы, знаки препинания, заглавные и строчные буквы важны!
#
# Sample Input:
#
# 99
# Sample Output:
#
# Для числа 99 предыдущим будет число 98.
# Для числа 99 следующим будет число 100.

# n = int(input())
# print(f"Для числа {n} предыдущим будет число {n-1}.")
# print(f"Для числа {n} следующим будет число {n+1}.")
#
# ______________________________________________________
# Напишите программу для перевода натурального значения секунд в значение минут определенного формата.
#
# Sample Input 1:
#
# 99
# Sample Output 1:
#
# 99 сек - это 1 мин. 39 сек.

# n = int(input())
# print(f'{n} сек - это {n//60} мин. {n%60} сек.')
#
# ________________________________________________________
# Вам поступает на вход два натуральных числа - ширина экрана и его высота в пикселях. В результате на экране разрешение экрана и общее количество пикселей в определенном формате. Все знаки препинания, пробелы, регистр букв важны. Также обратите внимание, что в этом месте «1920 x 1080» стоит английская буква «x»
#
# Sample Input:
#
# 1920 1080
# Sample Output:
#
# Разрешение экрана: 1920 x 1080.
# Общее количество пикселей = 2073600.

# ____________________________________________________________
# Вам поступает на вход два натуральных числа - ширина экрана и его высота в пикселях. В результате на экране разрешение экрана и общее количество пикселей в определенном формате. Все знаки препинания, пробелы, регистр букв важны. Также обратите внимание, что в этом месте «1920 x 1080» стоит английская буква «x»
#
# Sample Input:
#
# 1920 1080
# Sample Output:
#
# Разрешение экрана: 1920 x 1080.
# Общее количество пикселей = 2073600.

# a, b = map(int, input().split())
# print(f'Разрешение экрана: {a} x {b}.')
# print(f'Общее количество пикселей = {a * b}.')
#
# ______________________________________________________________
# Нашей программе поступает на вход x, y, z - три целых числа, обозначающие координаты вектора А. Затем необходимо найти координаты вектора B, путем увеличения на 5 каждой из координаты вектора А.
# #
# # Оба вектора необходимо распечатать в определенном формате
# #
# # Sample Input 1:
# #
# # 1
# # 2
# # 3
# # Sample Output 1:
# #
# # Vector A(1, 2, 3)
# # Vector B(6, 7, 8)

# a, b, c = int(input()), int(input()), int(input())
# print(f'Vector A({a}, {b}, {c})')
# print(f'Vector A({a + 5}, {b + 5}, {c + 5})')

# ________________________________________________

# Допишите программу ниже, чтобы она вывела через пробел в одной строке значения самого маленького и самого большого элементов списка my_list.

#
# my_list = [-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -989, 29]
# print(min(my_list), max(my_list))
#
# ___________________________________________________

# n, m =map(int, input().split())
# answer = n + (n - 1) // (m - 1)
# print(answer)
# ________________________________________________________
#
# Пользователь вводит целые числа по одному в строке, последовательность оканчивается числом 0. Все, что вводится после 0 не относится к последовательности. Напишите программу, которая выводит сумму всех членов данной последовательности.
#
# Sample Input 1:
#
# 1
# 2
# 3
# 0
# 5
# 6
# Sample Output 1:
#
# 6

# n = int(input())
# s = 0
# count = -1
# while s <= n:
#     a=s
#     count += 1
#     n1 = int(input())
#     s += n1
# print("Довольно!")
# print(a)
# print(count)
# _______________________________________________________
# Ване на день рождения подарили n кубиков. Он с друзьями решил построить из них пирамиду. Ваня хочет построить пирамиду следующим образом: на верхушке пирамиды должен находиться 1 кубик, на втором уровне — 1 + 2 = 3 кубика, на третьем — 1 + 2 + 3 = 6 кубиков, и так далее. Таким образом, на i-м уровне пирамиды должно располагаться 1 + 2 + ... + (i - 1) + i кубиков.
# n = int(input())
# used_cubers = 0
# cubes_in_row = 0
# row = 0
# while used_cubers <= n:
#     row +=1
#     cubes_in_row = cubes_in_row + row
#     used_cubers += cubes_in_row
# print(row -1)

# _______________________________________________
from math import *

# n, m = map(int, input().split())
# list1 = list(map(int, input().split()))
# list2 = list(map(int, input().split()))
# list3 = list1 + list2
# print(*sorted(list3))
#
# _________________________________________________
# Программа получает на вход натуральное число n > 1. Выведите минимальный делитель этого числа, отличный от единицы.
#
# К примеру для числа 12 делителями являются 1, 2, 3, 4, 6, 12.
#
# Sample Input 1:
#
# 12
# Sample Output 1:
#
# 2
#
# n = int(input())
# a = []
# for i in range(1,n+1):
#     if n % (i) == 0:
#         if i == 1:
#             continue
#         a.append(i)
# print(min(a))

# _______________________________________________________
# Давайте переберем все числа от а до b включительно и будем их выводить на экран, при этом нужно выполнить следующие условия:
#
# пропускать (не выводить) числа, которые делятся на 2 или на 3
# если встречаете число, кратное 777, необходимо принудительно закончить цикл, само это число не выводить

# n1, n2  = int(input()), int(input())
# n1 = n1 - 1
# while n1 < n2 :
#     n1 +=1
#     if n1 == 777:
#          break
#     if n1 % 2 == 0:
#          continue
#     if n1 % 3 == 0:
#          continue
#     print(n1)

# ________________________________________________________
#
# Вам на вход поступает слово и ваша задача в цикле while обойти все его буквы и распечатать их в формате фразы:
#
# «Текущая буква: <letter>».
#
# Как только вы встретите строчные английские буквы «e» или «a» нужно вывести фразу «Ага! Нашлась», перестать печатать буквы и принудительно выйти из цикла.
#
# В случае, если в слове не оказалось букв «e» или «a» необходимо вывести фразу «Распечатали все буквы»
#
# Sample Input 1:
#
# phrase
# Sample Output 1:
#
# Текущая буква: p
# Текущая буква: h
# Текущая буква: r
# Ага! Нашлась
#
# n = input()
# i=0
# while len(n) != i:
#     if n[i] == 'e' or n[i] == 'a':
#         print('Ага! Нашлась')
#         break
#     print(f'Текущая буква: {n[i]}')
#     i+=1
# else:
#     print('Распечатали все буквы')
# # ________________________________________________________



# На вход программе подается два натуральных числа aa и bb (a < ba< b). Напишите программу, которая находит натуральное число из отрезка [a; \, b][a;b] с максимальной суммой делителей.
#
# Формат входных данных
# На вход программе подаются два числа, каждое на отдельной строке.
#
# Формат выходных данных
# Программа должна вывести два числа на одной строке, разделенных пробелом: число с максимальной суммой делителей и сумму его делителей.

# a, b = int(input()), int(input())
# counter = 0 # счетчик подсчета суммы делителей
# number = 1 # число которое будем выводить (минимум 1)
# summa = 0  # тут будет сумма делителей, которую надо будет вывести
# for i in range(a, b + 1):  # проверяем каждое число в [a;b]
#     counter = 0 # обнуляем счетчик для каждого i
#     for j in range(1, i + 1):  # берем по очереди каждый делитель числа от [1 до самого числа]
#         if i % j == 0:  # если число делится на j без остатка, значит j - делитель числа
#             counter += j  # создаем сумму делителей
#     if counter >= summa:  # если сумма делителей больше или равна, чем суммаа делителей предыдущего числа
#         summa = counter  # то counter теперь равно кол-ву делителей этого числа вместо кол-ва предыдущего
#         number = i  # число у которого делителей оказалось больше, теперь равно number
# print(number, summa) # в конце концов, выводим само число (у которого больше делителей) и сумму этих делителей
#
# _____________________________________________________
# Дано натуральное число nn. Напишите программу, которая выводит значение суммы 1!+2!+3!+\ldots+n!1!+2!+3!+…+n!.
#
# Формат входных данных
# На вход программе подается одно натуральное число.

# import math
# n = int(input())
# sum_factorial = 0
# for i in range(1, n +1):
#     sum_factorial += math.factorial(i)
# print(sum_factorial)
# _______________________________________________________
# На вход программе поступает список из целых чисел. Ваша задача найти в данном списке наименьшее положительное значение. В случае, если положительных значений нет, выведите строку "Empty"
#
# Sample Input 1:
#
# 8 11 -9 0 5 -20
# Sample Output 1:
#
# 5
#
#
# a= list(map(int,input().split()))
# b=[]
# for i in range(len(a)):
#     if a[i]>0:
#         b.append(a[i])
# if len(b)<=0:
#     print("Empty")
# else:
#     print(min(b))
# __________________________________________________________

# lst=[]
# count=1
# for i in range(4):
#     lst.append(input())
# for i in lst:
#     print(i)
# for i in range(4):
#     for j in range(4):
# #         print([i][j], end=' ')
# #     print()
#         if lst[i][j] == lst[i+1][j] == lst[i][j+1] == lst[i+1][j+1]:
#             print('No')
#             break
#         else:
#             print('Yes')


# ________________________________________________________
# Вывести список, содержащий нечетные натуральные числа в интервале  [ nn; n^2n
# 2
#   ]
#
# Sample Input 1:
#
# 7
# Sample Output 1:
#
# [7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49]

# n = int(input())
#
# b = [i for i in range(n, n**2 + 1) if i % 2 != 0]
# print(b)
# ____________________________________________________
#
# Создайте список первых букв каждого слова из строки st и выведите его на экран
# st = 'Create a list of the first letters of every word in this string'
#
# b=st.split()
#
# t = [b[i][0] for i in range(len(b))]
# print(t)
# ____________________________________________________
# При помощи генератора-списков создайте список, состоящий из слов,  начинающихся с буквы 't' или 'T'. Слова возьмите из переменной phrase, также не забывайте про метод split()
#
# В качестве ответа выведите полученный список, слова в нем должны стоять в том же порядке, в котором они стояли в изначальной фразе
# phrase = 'Take only the words that start with t in this sentence'
#
# phrase = 'Take only the words that start with t in this sentence'
# print([i for i in phrase.split() if i[0] in 't' or i[0] in 'T'])

# ______________________________________________________
# На вход программе подается четное число n, \, n \ge 2n,n≥2. Напишите программу, которая выводит список четных чисел
#
#  [2, 4, 6, ..., n].
#
#
# n = int(input())
# print([i for i in range(2, n +1) if i % 2 == 0])

# ______________________________________________________

# На вход программе подаются две строки текста, содержащие целые числа. Из данных строк формируются списки чисел L и M. Напишите программу, которая создает третий список, элементами которого являются суммы соответствующих элементов списков L и M. Далее программа должна вывести каждый элемент полученного списка на одной строке через 1 пробел.
#
# Формат входных данных
# На вход программе подаются две строки текста, содержащие целые числа, разделенные символом пробела.
#
# Формат выходных данных
# Программа должна вывести текст в соответствии с условием задачи.

# n1 = list(map(int, input().split()))
# n2 = list(map(int, input().split()))
# a =[]
# for i in range(len(n1)):
#     a.append(n1[i] + n2[i])
# print(*a)
# ---------
# a = [int(i) for i in input().split()]
# b = [int(i) for i in input().split()]
# print(*[x + y for x, y in zip(a, b)])

# _________________________________________________________
# На вход программе подается строка текста, содержащая натуральные числа. Напишите программу, которая вставляет между каждым числом знак +, а затем вычисляет сумму полученных чисел.
#
# Формат входных данных
# На вход программе подается строка текста, содержащая натуральные числа, разделенные символом пробела.


# n = list(map(int, input().split()))
# s = 0
# for i in range(len(n)):
#     s += int(n[i])
# print(*n, sep='+', end='=')
# print(s)

# ________________________________________________________
#
# На вход программе подается строка текста. Напишите программу, которая определяет является ли введенная строка корректным телефонным номером. Строка текста является корректным телефонным номером если она имеет формат:
#
# abc-def-hijk или
# 7-abc-def-hijk
# где a, b, c, d, e, f, h, i, j, k – цифры от 0 до 9.

# n = input().split("-")
# c = [len(i) for i in n]
# if c == [3, 3, 4] and ''.join(n).isdigit():
#     print("YES")
# elif c == [1, 3, 3, 4] and ''.join(n).isdigit() and n[0] == '7':
#     print("YES")
# else:
#     print("NO")
#
# ______________________________________________
#
# На вход программе подается строка текста. Напишите программу, использующую списочное выражение, которая находит длину самого длинного слова.
#
# Формат входных данных
# На вход программе подается строка текста.

# n = input().split()
# c = [len(i) for i in n]
# print(max(c))

# __________________________________________
# На вход программе подается строка текста. Напишите программу, использующую списочное выражение, которая преобразует каждое слово введенного текста в "молодежный жаргон" по следующему правилу:
#
# первая буква каждого слова удаляется и ставится в конец слова;
# затем в конец слова добавляется слог "ки".
# Формат входных данных
# На вход программе подается строка текста на русском языке.
#
# Формат выходных данных
# Программа должна вывести текст в соответствии с условием задачи.

# n = input().split()
# print(*([i[1:] + i[0] + 'ки' for i in n]))
# _______________________________________________

# n = int(input())
# counter = 0
#
# for i in range(1, n + 1):
#     if i % 3 == 0 and i % 7 != 0:
#         counter += 1
# print(counter)

# Дано натуральное число. Напишите программу, которая вычисляет:
# n = input()
# number3 = 0
# last = n[-1]
# lastnumber = 0
# coun=0
# more5 = 0
# more7 = 1
# howmany05 = 0
# for i in n:
#     if i in '3':
#         number3 +=1
#     if i in last:
#         lastnumber +=1
#     if int(i)%2==0:
#         coun +=1
#     if int(i)>5:
#        more5 +=int(i)
#     if int(i)>7:
#        more7 *=int(i)
#     if int(i) == 0 or int(i) ==5:
#       howmany05 +=1
#
#
# print(number3)
# print(lastnumber)
# print(coun)
# print(more5)
# print(more7)
# print(howmany05)

# ______________________________________________________
# city = input()
# flag = 0
# for key, value in countries.items():
#     if city in value:
#         flag +=1
#         print(f'INFO: {city} is a city in {key}')
#     else:
#         continue
# if flag==0:
#     print(f'ERROR: Country for {city} not found')
#
# countries = {
#     "Sweden": ["Stockholm", "Göteborg", "Malmö"],
#     "Norway": ["Oslo", "Bergen", "Trondheim"],
#     "England": ["London", "Birmingham", "Manchester"],
#     "Germany": ["Berlin", "Hamburg", "Munich"],
#     "France": ["Paris", "Marseille", "Toulouse"]
# }
#
#
# city = input()
# flag = 0
# for key, value in countries.items():
#     if city in value:
#         flag +=1
#         print(f'INFO: {city} is a city in {key}')
#     else:
#         continue
# if flag==0:
#     print(f'ERROR: Country for {city} not found')

# _______________________________

# s = input()
# a = s[:s.find('h') + 1]
# b = s[s.rfind('h') :]
# s = s[s.rfind('h') -1 : s.find('h') :-1]
# # print(a)
# # print(b)
# # print(s)
# print(a + s + b)

# _______________________________________________________
#
# Мы уже с вами подсчитывали сколько раз встречается число в списке при помощи метода подсчета. Там мы использовали список для хранения найденного количества
#
# Теперь ваша задача научиться использовать словарь для подсчета количества. Вашей программе поступает на вход строка, вам необходимо подсчитать сколько раз встретилась каждая буква в этой строке без учета регистра, при этом цифры и символы пунктуации нужно пропустить. Ответ нужно сохранить в словаре, в котором ключ - буква, а значение - количество раз, сколько эта буква встретилась в строке. В качестве ответа нужно вывести словарь
#
# Sample Input 1:
#
# aabbbc
# Sample Output 1:
#
# {'a': 2, 'b': 3, 'c': 1}

# n = input().lower()
# d ={}
# for i in n:
#     if 'a' <= i <= 'z':
#         if i in d:
#             d[i] +=1
#         else:
#            d[i] = 1
#     else:
#         continue
# print(d)
# ____________________________
# n1 = sorted(input())
# n2 = sorted(input())
# if n1 == n2:
#     print('YES')
# else:
#     print('NO')
#
# _________
# print('YES' if sorted(input()) == sorted(input()) else 'NO')
#
# people = [
#     ['Amy Smith', '694.322.8133x22426'],
#     ['Brian Shaw', '593.662.5217x338'],
#     ['Christian Sharp', '118.197.8810'],
#     ['Sean Schmidt', '9722527521'],
#     ['Thomas Long', '163.814.9938'],
#     ['Joshua Willis', '+1-978-530-6971x601'],
#     ['Ann Hoffman', '434.104.4302'],
#     ['John Leonard', '(956)182-8435'],
#     ['Daniel Ross', '870-365-8303x416'],
#     ['Jacqueline Moon', '+1-757-865-4488x652'],
#     ['Gregory Baker', '705-576-1122'],
#     ['Michael Spencer', '(922)816-0599x7007'],
#     ['Austin Vazquez', '399-813-8599'],
#     ['Chad Delgado', '979.908.8506x886'],
#     ['Jonathan Gilbert', '9577853541']
# ]
#
# phone_book = {i[1]:i[0] for i in people}
# print(phone_book)
#
# def keanu_reeves(x):
#     n = 0
#     for i in range(1,x+1):
#         n +=i
#     print(f"Я знаю, что сумма чисел от 1 до {x} равна {n}")
# a = int(input())
# keanu_reeves(a)
# ______________________________________________________________
# Напишите функцию check_password, которая проверяет переданный ей пароль на сложность и печатает на экран результат проверки.
#
# Сложным паролем будет считаться комбинация символов, в которой :
#
# Есть хотя бы 3 цифры
# Есть хотя бы одна заглавная буква
# Есть хотя бы один символ из следующего набора "!@#$%*"
# Общая длина не менее 10 символов
# Если пароль прошел все проверки, функция должна вывести на экран фразу "Perfect password", в противном случае - "Easy peasy"Напишите функцию check_password, которая проверяет переданный ей пароль на сложность и печатает на экран результат проверки.
#
# Сложным паролем будет считаться комбинация символов, в которой :
#
# Есть хотя бы 3 цифры
# Есть хотя бы одна заглавная буква
# Есть хотя бы один символ из следующего набора "!@#$%*"
# Общая длина не менее 10 символов
# Если пароль прошел все проверки, функция должна вывести на экран фразу "Perfect password", в противном случае - "Easy peasy"
# def check_password(x):
#      count =0
#      count1 = 0
#      count2 = 0
#      for i in x:
#          if i in '0123456789':
#              count +=1
#          if "A" <= i <="Z":
#              count1 += 1
#          if i in "!@#$%*":
#              count2 += 1
#      if count >=3  and count1 >= 1 and count2 >=1 and len(x)>=10:
#          print("Perfect password")
#      else:
#          print("Easy peasy")
#
# a = input()
# check_password(a)


# __________________________________________
#
# Создайте функцию count_letters, которая принимает на вход фразу и подсчитывает, какое количество в ней строчных(K) и заглавных (N) букв, все остальные символы игнорируются. Функция должна вывести на экран информацию о найденных буквах в определенном формате.
#
# Количество заглавных символов: N
# Количество строчных символов: K
#
# Вам необходимо написать только определение функции.
#
# Sample Input 1:
#
# Привет, Старина
# Sample Output 1:
#
# Количество заглавных символов: 2
# Количество строчных символов: 11

# def count_letters(x):
#     count = 0
#     count1=0
#     for i in x:
#         if i.isupper():
#              count +=1
#         elif i.isalpha():
#             count1 +=1
#     print(f"Количество заглавных символов: {count}")
#     print(f"Количество строчных символов: {count1}")
# n = input()
# count_letters(n)
# _______________________________
# Напишите функцию print_initials(name, surname, middlename), которая принимает три параметра:
#
# name – имя человека;
# surname – фамилия человека;
# middlename– отчество человека;
# а затем выводит на печать фамилию и инициалы в определенном формате (первая буква фамилии должна стать заглавной, все остальные строчные; в имени и отчестве остаются только по одной букве в верхнем регистре).
#
# Ваша задача написать только определение функции, вызывать ее не нужно
# # объявление функции
# def print_initials(name, surname, middlename):
#     print(surname.capitalize(), name[0].upper() + '.', middlename[0].upper() + '.')
#
# # считываем данные
# name = input()
# surname = input()
# middlename = input()
#
# # вызываем функцию
# print_initials(name, surname, middlename)

# def factorial(x):
#     ph = 1
#     for i in range(1, x + 1):
#         ph *=i
#     print(ph)
#
# n = int(input())
# factorial(n)
# ___________________________________________
# Ваша задача написать функция find_duplicate, которая принимает один аргумент - список чисел. Функция должна возвращать список из дублей, каждый дубль нужно брать только один раз в том порядке, в котором они встречаются в исходном списке. Под дублем будем подразумевать число, которое присутствовало в списке несколько раз.
#
# def find_duplicate(s):
#     dupl = []
#     for i in s:
#         if s.count(i) >1 and i not in dupl:
#             dupl.append(i)
#     return dupl

# _________________________________________
# Напишите функцию first_unique_char, которая принимает строку символов и возвращает позицию первого уникального символа в строке. В случае, если уникальных символов в переданной строке нет, верните -1. Регистр символов не учитывайте.
#
# Ваша задача написать только определение функции first_unique_char
#
# Sample Input 1:
#
# python
# Sample Output 1:
#
# 0

# def first_unique_char(x):
#     a = []
#
#     for i in x.lower():
#         if x.count(i) == 1:
#            a.append(x.find(i))
#     if len(a) > 0:
#         return a[0]
#     else:
#         return -1
#
#
# n=input()
# first_unique_char(n)
#
# ____________________________________________
#
# Ваша задача написать функцию format_namelist, которая принимает список словарей, у каждого словаря в списке есть только ключ name
#
# Функция format_namelist должна вернуть отформатированную строку, в которой все имена из списка разделяются запятой кроме последних двух имен, они должны быть разделены союзом "и". Если в списке нет ни одного имени, функция должна вернуть пустую строку. Ниже представлены примеры:
#
# format_namelist([ {'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'} ])
# # returns 'Bart, Lisa и Maggie'

# def ormat_namelist(x):
#     a = []
#     for i
#
# n = dict(input())
# ormat_namelist(n)

# def format_namelist(h):
#     a = []
#     for i in h:
#         for j in i.values():
#             a.append(j)
#
#     b = []
#     s = ''
#     if len(a)==1:
#         return a[0]
#     elif len(a) == 2:
#         return a[0] + ' и ' + a[1]
#     elif len(a)>=3:
#         for j in range(len(a) ):
#             s = (', '.join(a[:-1])) +' и '+a[-1]
#         return s
#     else:
#         return ''
# format_namelist([{'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'}])
# ________________________________________
# Напишите функцию draw_triangle(), которая выводит звездный равнобедренный треугольник с основанием и высотой равными 1515 и 88 соответственно:
#
#        *
#       ***
#      *****
#     *******
#    *********
#   ***********
#  *************
# ***************
#
#
# def draw_triangle():
#     m = 15
#     for i in range(1, m + 1, 2):
#         print(' ' * ((m - i) // 2) + '*' * i)
#
# # основная программа
# draw_triangle()

# _______________________________________
# Интернет магазин осуществляет экспресс доставку для своих товаров по цене 10001000 рублей за первый товар и 120120 рублей за каждый последующий товар. Напишите функцию get_shipping_cost(quantity), которая принимает в качестве аргумента натуральное число quantity – количество товаров в заказе и возвращает стоимость доставки.
#
# Примечание. Следующий программный код:
#
# print(get_shipping_cost(1))
# print(get_shipping_cost(3))
# должен выводить:
#
# 1000
# 1240
#
# # объявление функции
# def get_shipping_cost(quantity):
#     return 1000 + (quantity - 1) * 120
#
# # считываем данные
# n = int(input())
#
# # вызываем функцию
# print(get_shipping_cost(n))

# _____________________________
# Напишите функцию compute_binom(n, k), которая принимает в качестве аргументов два натуральных числа n и k и возвращает значение биномиального коэффициента, равного \dfrac{n!}{k! (n-k)!}
# k!(n−k)!
# n!
# ​
#  .
#
# Примечание 1. Факториалом натурального числа nn, называется произведение всех натуральных чисел от 11 до nn, то есть
# n!=1\cdot2\cdot3\cdot…\cdot n
# n!=1⋅2⋅3⋅…⋅n
#
# Примечание 2. Реализуйте вспомогательную функцию factorial(n), вычисляющую факториал числа или воспользуйтесь уже готовой функцией из модуля math.

# import math
#
#
# def compute_binom(n, k):
#     return (math.factorial(n)/ (math.factorial(k)*((math.factorial(n) - math.factorial(k)))))
#
# # считываем данные
# n = int(input())
# k = int(input())
#
# # вызываем функцию
# print(compute_binom(n, k))

# ________________________________
# Напишите функцию number_to_words(num), которая принимает в качестве аргумента натуральное число num и возвращает его словесное описание на русском языке.
#
# Примечание 1. Считайте, что число 1 \le num \le 991≤num ≤99.
#
# Примечание 2. Следующий программный код:
#
# print(number_to_words(7))
# print(number_to_words(85))
# должен выводить:
#
# семь
# восемьдесят пять
#
# zero_to_ninety_nine = ['ноль', 'один', 'два', 'три', 'четыре', 'пять', 'шесть', 'семь', 'восемь', 'девять', 'десять', 'одиннадцать', 'двенадцать', 'тринадцать', 'четырнадцать', 'пятнадцать', 'шестнадцать', 'семнадцать', 'восемнадцать', 'девятнадцать', 'двадцать', 'двадцать один', 'двадцать два', 'двадцать три', 'двадцать четыре', 'двадцать пять', 'двадцать шесть', 'двадцать семь', 'двадцать восемь', 'двадцать девять', 'тридцать', 'тридцать один', 'тридцать два', 'тридцать три', 'тридцать четыре', 'тридцать пять', 'тридцать шесть', 'тридцать семь', 'тридцать восемь', 'тридцать девять', 'сорок', 'сорок один', 'сорок два', 'сорок три', 'сорок четыре', 'сорок пять', 'сорок шесть', 'сорок семь', 'сорок восемь', 'сорок девять', 'пятьдесят', 'пятьдесят один', 'пятьдесят два', 'пятьдесят три', 'пятьдесят четыре', 'пятьдесят пять', 'пятьдесят шесть', 'пятьдесят семь', 'пятьдесят восемь', 'пятьдесят девять', 'шестьдесят', 'шестьдесят один', 'шестьдесят два', 'шестьдесят три', 'шестьдесят четыре', 'шестьдесят пять', 'шестьдесят шесть', 'шестьдесят семь', 'шестьдесят восемь', 'шестьдесят девять', 'семьдесят', 'семьдесят один', 'семьдесят два', 'семьдесят три', 'семьдесят четыре', 'семьдесят пять', 'семьдесят шесть', 'семьдесят семь', 'семьдесят восемь', 'семьдесят девять', 'восемьдесят', 'восемьдесят один', 'восемьдесят два', 'восемьдесят три', 'восемьдесят четыре', 'восемьдесят пять', 'восемьдесят шесть', 'восемьдесят семь', 'восемьдесят восемь', 'восемьдесят девять', 'девяносто', 'девяносто один', 'девяносто два', 'девяносто три', 'девяносто четыре', 'девяносто пять', 'девяносто шесть', 'девяносто семь', 'девяносто восемь', 'девяносто девять']
# # объявление функции
# def number_to_words(num):
#     return zero_to_ninety_nine[num]
#
# # считываем данные
# n = int(input())
#
# # вызываем функцию
# print(number_to_words(n))
#
# ____________________________________________________

# Искомый месяц
# Напишите функцию get_month(language, number), которая принимает на вход два аргумента language – язык ru или en и number – номер месяца (от 1 до 12) и возвращает название месяца на русском или английском языке.
#
# Примечание. Следующий программный код:
#
# print(get_month('ru', 1))
# print(get_month('ru', 12))
# print(get_month('en', 1))
# print(get_month('en', 10))
# должен выводить:
#
# январь
# декабрь
# january
# october

#
# ru = [0, 'январь', 'февраль', 'март', 'апрель', 'май', 'июнь', 'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь']
# en = [0, 'january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
#
# # объявление функции
# def get_month(language, number):
#     if language == "ru":
#         return ru[number]
#     return en[number]
#
#
# # считываем данные
# lan = input()
# num = int(input())
#
# # вызываем функцию
# print(get_month(lan, num))

# ___________________________________________________
#
# Магические даты
# Магическая дата – это дата, когда день, умноженный на месяц, равен числу образованному последними двумя цифрами года.
#
# Напишите функцию, is_magic(date) которая принимает в качестве аргумента строковое представление корректой даты и возвращает значение True если дата является магической и False в противном случае.
#
# Примечание. Следующий программный код:
#
# print(is_magic('10.06.1960'))
# print(is_magic('11.06.1960'))
# должен выводить:
#
# True
# False
#
# # объявление функции
# def is_magic(date):
#     if (int(date[:2]) * int(date[3:5])) == (int(date[8:])):
#
#         return True
#     return False
#
# # считываем данные
# date = input()
#
# # вызываем функцию
# print(is_magic(date))
#
# __________________________________________

# Панграмма – это фраза, содержащая в себе все буквы алфавита. Обычно панграммы используют для презентации шрифтов, чтобы можно было в одной фразе рассмотреть все глифы.
#
# Напишите функцию, is_pangram(text) которая принимает в качестве аргумента строку текста на английском языке и возвращает значение True если текст является панграммой и False в противном случае.
#
# Примечание 1. Гарантируется, что введенная строка содержит только буквы английского алфавита.
#
# Примечание 2. Следующий программный код:
#
# print(is_pangram('Jackdaws love my big sphinx of quartz'))
# print(is_pangram('The jay pig fox zebra and my wolves quack'))
# print(is_pangram('Hello world'))
# должен выводить:
#
# True
# True
# False

# ________________________________________________
# Панграмма – это фраза, содержащая в себе все буквы алфавита. Обычно панграммы используют для презентации шрифтов, чтобы можно было в одной фразе рассмотреть все глифы.
#
# Напишите функцию, is_pangram(text) которая принимает в качестве аргумента строку текста на английском языке и возвращает значение True если текст является панграммой и False в противном случае.
#
# Примечание 1. Гарантируется, что введенная строка содержит только буквы английского алфавита.
#
# Примечание 2. Следующий программный код:
#
# print(is_pangram('Jackdaws love my big sphinx of quartz'))
# print(is_pangram('The jay pig fox zebra and my wolves quack'))
# print(is_pangram('Hello world'))
# должен выводить:
#
# True
# True
#
# l = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
#
# # объявление функции
# def is_pangram(text):
#     for i in text.lower():
#         if i in l:
#             l.remove(i)
#     if l == []:
#        return True
#     else:
#         return False
# # считываем данные
# text = input()
#
# # вызываем функцию
# print(is_pangram(text))

# _________---------------
#
# Напишите программу для вычисления суммы двух матриц.
#
# Формат входных данных
# На вход программе подаются два натуральных числа nn и mm — количество строк и столбцов в матрицах, затем элементы первой матрицы, затем пустая строка, далее следуют элементы второй матрицы.
#
# Формат выходных данных
# Программа должна вывести результирующую матрицу, разделяя элементы символом пробела.
#
# n, m = map(int, input().split())
#
# matrix1 = [[int(i) for i in input().split()] for j in range(n)]
# a = input()
# matrix2 = [[int(i) for i in input().split()] for j in range(n)]
# matrix3 = [[0 for _ in range(m)] for _ in range(n)]
#
# for i in range(n):
#     for j in range(m):
#         matrix3[i][j] +=matrix1[i][j] + matrix2[i][j]
#
# for r in matrix3: print(*r)

# _____________________________________________
#
# a,b,c = list(map(set,input().split()))
# print(c, b, a)
# if set(a) == set(b) and set(c) == set(b) and set(c) == set(a):
#     print("YES")
# else:
#     print("NO")
# _________________________________________
# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# def f(x):
#     return x**2
#
# def s(x):
#     return x**3
#
# print(list(map(f, numbers)))
# print(list(map(s, numbers)))
#
# _____________________
# Напишите программу, которая отфильтрует список numbers так, чтобы в нем остались только четные значения. Используйте при этом lambda функцию.
#
# Распечатайте получившийся список
#
# Sample Input:
#
#
# Sample Output:
#
# [2, 4, 6, 8, 10]
# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#
# n = list(filter(lambda x: x % 2 == 0, numbers))
# print(n)

# ______________________________
# Вам дан список numbers, в нем есть и отрицательные числа и нули и положительные значения. Гарантируется, что список целиком состоит только из чисел.
#
# Необходимо при помощи функций filter и len определить сколько в этом списке отрицательных значений, сколько нулей и сколько положительных. Вывести найденные значения в том же порядке
#
# Sample Input:
#
# Sample Output:
#
# 480 2 518
#
#
# numbers = [54, 71, 65, 51, 36, -82, -32, 61, -61, 92, 17, -68, -62, 40, 16, -49, -51, -38, 60, -24, -61, 3, -26, -46, -97, -28, 36, 7, 52, 56, -96, -69, 67, 76, 16, 36, 38, 74, 11, -87, 69, 69, -69, -61, 92, 67, -45, -26, 94, 38, 27, -26, 10, 55, 28, -81, 53, -75, -32, -83, 38, 83, -40, -51, 88, 28, 76, 25, 84, -79, -69, -65, 6, 12, 81, -58, -92, 44, -41, 60, -14, -65, 7, 64, -40, -25, -91, -23, -19, -40, -4, 36, 38, 28, -27, -28, 72, 47, -95, 47, 10, 31, 62, -75, 22, -34, 44, -62, -30, -41, 19, -13, 30, -11, -54, -46, -80, -57, -60, 72, -49, 84, 5, 66, 62, -35, 69, 23, 41, -15, 75, -53, 94, -76, -28, -41, -17, 71, 67, -50, 18, 65, -16, -27, -88, 21, -42, 58, 85, 36, 9, -72, -26, -73, -1, 41, -87, 85, 5, -92, -60, -33, 33, -74, 17, 47, -38, -95, -39, 64, 85, -27, -42, -91, -39, -15, -75, 78, -54, 26, -10, -3, 89, -11, -71, -85, 63, 9, -59, 72, 27, 40, 99, -9, 77, 64, -39, -28, 73, -50, -80, -74, 52, 26, 53, -18, 22, 70, 85, 1, -90, 53, -19, -80, -14, -29, -64, -21, 23, 99, 15, -52, 66, 30, 82, -81, -30, -68, 30, -25, -63, 33, 1, 0, 84, 18, -35, 31, -34, 10, 48, -37, -41, -94, -1, -14, -87, -37, -6, 48, 38, 33, -13, 71, -81, 45, -63, 52, -35, 34, -88, -82, -7, -92, -22, 96, -28, 0, 21, 74, -28, 81, 81, 44, -16, 17, -95, 18, -73, 15, -61, 6, -43, -67, -31, -61, -72, -66, 60, 67, -13, 47, 29, 44, -93, 55, -13, -23, 74, 79, 32, -20, 33, 17, -48, 7, 24, 19, 89, -60, 34, 81, 18, -39, 56, 10, -32, 46, -33, -75, -99, -37, -23, 59, -33, -1, 75, -65, 92, 80, 51, -59, -28, -22, -47, -1, 28, -85, 1, 23, -15, -66, -97, -25, 7, 17, -87, -60, 14, -70, 88, 20, 40, -89, 38, -41, -97, 76, 80, 43, 22, -72, -38, 47, -2, 12, 58, -91, 82, -98, 50, 15, -33, -56, 69, -27, 94, -90, 92, -71, -73, -71, -78, 22, -86, -48, 10, 46, 19, 68, -23, 52, -42, 74, 44, 89, -71, 93, 43, -86, 79, 3, -56, 14, 41, 15, -37, 77, -9, 36, 51, -89, 1, 37, 82, 27, 72, -92, 91, 94, 71, -81, -49, -42, 26, 57, -30, -40, 86, -77, -85, 1, 71, 16, 73, -82, 26, -90, 72, 14, -65, -55, 34, 45, 66, -64, -40, 92, 42, -78, -22, 53, -18, -41, -75, 10, -59, -55, 8, -90, -3, -65, 43, -49, -86, -96, 69, 48, 27, -48, -42, -34, -6, 7, 50, -55, -65, 79, 30, 16, -21, -98, -73, -25, -20, -51, 20, 17, -91, 34, 96, 12, 13, -58, -73, -82, 19, -48, -61, 57, 96, 74, 34, -63, 38, -27, -12, -24, 94, -25, -10, -41, 53, -13, 16, -21, 24, 96, 95, 58, 83, 10, 42, -11, -33, 10, 38, -6, -66, -40, -36, -99, -55, 37, -81, -93, 67, -77, -3, 77, 25, 38, -16, 21, -82, 77, 95, 73, 9, 94, -27, -21, -33, -90, 31, 98, 28, -63, 75, 53, -17, -1, 6, 51, 11, -92, 30, -24, 12, 47, -75, -15, -63, 57, 3, 37, -82, -28, -26, -3, -30, -90, -45, 20, -41, 72, -42, 15, -3, 92, 57, -1, 40, -65, 88, 28, -76, 52, -63, -51, 59, 69, -39, -47, -1, -18, -57, 68, 77, 66, 62, -71, 31, -50, 61, 88, 98, 5, 98, -57, -46, 2, 90, 43, 67, 76, -81, -57, 77, 25, -66, -81, -92, -76, 72, 14, 59, 52, 36, 20, -2, 92, 58, 36, -34, 94, -74, 42, -56, 96, -81, 69, -83, 71, -13, -13, 56, 86, -29, 58, -17, 65, 70, 74, 28, 8, 91, 51, 79, -57, -86, 5, -37, -67, -28, 56, 65, -90, 97, -20, 81, -85, -45, 46, -74, 76, -75, -7, 74, 82, 56, 14, -43, 20, -48, -99, 19, -39, -66, 44, -75, 24, -5, -70, 85, -12, 20, -85, -69, -26, -57, 28, -96, 42, -56, 13, 80, -48, 59, 11, -30, 4, -96, 58, 41, -2, -84, -51, 52, -69, 37, 60, -12, 48, -5, -48, 29, -62, 42, 15, 16, 65, 60, 43, -53, 4, 50, -21, 1, -21, -42, -57, -21, -50, -67, 77, -22, -5, 59, -67, 86, -77, 39, -67, 41, 83, -21, 33, 73, 55, 80, 93, 44, -71, 38, -93, 4, 83, -52, 75, -51, 1, -11, -45, 56, 81, 84, 70, 23, -36, -63, 69, 1, 86, -21, 53, -85, 70, -89, -31, -10, -94, -76, -17, -21, -60, 49, -22, -48, 67, 21, 18, 89, 20, 73, -43, -17, -52, 36, -21, 6, -37, -98, 94, 56, 31, 99, 86, 65, -19, -67, 46, 20, -29, -88, -54, 88, -12, -69, 17, 83, -94, 21, 59, -99, 70, -54, -35, 2, 58, 93, 1, -35, -44, 47, 40, 55, 10, -15, -96, -42, 10, -83, -82, -26, 48, 78, -72, 56, -99, -36, 25, 76, -3, -95, -38, -24, 96, 82, 7, 84, 46, 8, 93, -52, -86, 87, -85, -81, 52, -67, 52, -45, -93, -69, 60, -83, -20, -14, 80, -36, 62, -78, 3, -61, 51, 48, 73, 92, -65, 71, -86, 8, -14, 82, 58, -58, -21, 62, -38, 16, 20, -80, -78, 19, 19, 93, -83, 2, 71, 85, 71, -4, 81, 4, 90, 73, 21, -3, -55, 49, 66, -4, -6, 42, 76, -3, -94, 49, 55, -53, 12, 1, -25, 56, 93, -68, -21, 15, -13, 35, 71, -68, 34, -44, 48, 97, 51, 32, 87, 27, -85, -41, -27, 54, -91, -99, 83, -44, 70, -87, -76, 49, 99, 38, 15, 75, -54, -59, 22, 80, 49, -63, 8, -46, 97, -4, -92, -47, -20]
# n1 = list(filter(lambda x: x < 0, numbers))
# n2 = list(filter(lambda x: x == 0, numbers))
# n3 = list(filter(lambda x: x > 0, numbers))
# print(len(n1), len(n2), len(n3))
#
#
# ________________________________________
#
# Напишите программу, которая отсортирует список models по цвету в лексикографическом порядке (по алфавиту)
#
# Затем распечатайте элементы этого списка, каждый элемент на новой строке в формате:
#
# Производитель: <make>, модель: <model>, цвет: <color>
#
# models = [{'make': 'Nokia', 'model': 216, 'color': 'Black'},
#           {'make': 'Mi Max', 'model': 2, 'color': 'Gold'},
#           {'make': 'Samsung', 'model': 7, 'color': 'Blue'},
#           {'make': 'Apple', 'model': 10, 'color': 'Silver'},
#           {'make': 'Oppo', 'model': 9, 'color': 'Red'},
#           {'make': 'Huawei', 'model': 4, 'color': 'Grey'},
#           {'make': 'Honor', 'model': 3, 'color': 'Black'}]
#
# a = sorted(models, key=lambda x: x['color'])
# for i in a:
#     print(f'Производитель:', i['make'] + ',', 'модель:', str(i['model']) + ',', 'цвет:', i['color'])

# ________________________________________________
# Представьте, у нас есть список товаров и их стоимость, но мы хотим взглянуть на него в отсортированном виде. Вверху хотим видеть самые дорогие товары, внизу самые дешевые
#
# Программа будет принимать строки, в которых сперва указывается название товара, а затем через двоеточие с пробелом его цена - целое положительное число.
#
# Строка "конец" означает списка товаров и соответственно окончание ввода
#
# Все товары имеют уникальные названия, цены не дублируются.
#
# Ваша задача вывести список товаров по уменьшению цены
#
# Sample Input:
#
# Sony PlayStation 5: 46000
# Телевизор QLED Samsung QE65Q60TAU: 87090
# Смартфон Samsung Galaxy A11: 10000
# Планшет Samsung Galaxy Tab S6: 26600
# конец
# Sample Output:
#
# Телевизор QLED Samsung QE65Q60TAU
# Sony PlayStation 5
# Планшет Samsung Galaxy Tab S6
# Смартфон Samsung Galaxy A11
#
#
# n =[i.split(':') for i in iter(input, 'конец')]
# a = sorted(n, key=lambda x:int(x[1]), reverse=True)
# for i in a:
#     print(i[0])

# _______________________________________
# Премия Оскар
# Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет (Лео бы тогда давно купался в этих статуэтках)
#
# Ваша задача написать программу, которая находит информацию, кто из актеров получил наибольшее и наименьшее количество статуэток
#
# Входные данные
# Программа принимать на вход в первой строке натуральное число n - количество вручаемых сегодня наград. И затем в n следующих строках вводятся имена актеров - победителей.
#
# Выходные данные
# Нужно вывести в  отдельных строках имена актеров набравших наибольшее и наименьшее количество статуэток и через запятую их количество. Гарантируется, что всегда будет только один человек, набравших наибольшее и наименьшее количество статуэток.
#
# Sample Input:
#
# 6
# Леонардо Ди Каприо
# Джонни Депп
# Леонардо Ди Каприо
# Леонардо Ди Каприо
# Джонни Депп
# Мэтт Деймон
# Sample Output:
#
# Леонардо Ди Каприо, 3
# Мэтт Деймон, 1


# a = {}
# n = int(input())
# for i in range(n):
#     string = input()
#     if string not in a:
#         a[string] = 1
#     else:
#         a[string] += 1
# minimum = min(a.items(), key=lambda x: x[1])
# maximum = max(a.items(), key=lambda x: x[1])
# if len(a) >= 1:
#     print(*maximum, sep=', ')
#     print(*minimum, sep=', ')
# else:
#     for k, v in a.items():
#         print(f"{k}, {v}")

# ------------------------------


# ans = (len(set(objects)))
# print(ans)

# for obj in objects: # доступная переменная objects
#     ans += 1
# print(ans)
#
# a = set(objects)
# print(a)
# # s = {}
# # for i in range(objects):
# #     s.update(objects[i])
# # print(s)

# ________________________________
# Создайте класс Counter, экземпляры которого будут подсчитывать внутри себя значения.
#
# В классе Counter нужно определить метод start_from, который принимает один необязательный аргумент - значение, с которого начинается подсчет, по умолчанию равно 0
#
# Также нужно создать метод increment, который увеличивает счетчик на 1.
#
# Затем необходимо создать метод display, который печатает фразу "Текущее значение счетчика = <value>" и метод reset,  который обнуляет экземпляр счетчика
#
# Пример работы с классом Counter

#
# class Counter:
#     def start_from(self, x = 0):
#         self.x = x
#     def increment(self):
#         self.x += 1
#     def display(self):
#         print(f'Текущее значение счетчика = {self.x}')
#     def reset(self):
#         self.x = 0
#
# x = Counter()
# x.start_from(9)
# x.reset()
# x.increment()
# x.display() # печатает "Текущее значение счетчика = 1"

# x.increment()
# x.display() # печатает "Текущее значение счетчика = 2"
# ______________________________
# Создайте класс Point. У этого класса должны быть
#
# метод set_coordinates, который принимает координаты по x и по y, и сохраняет их в экземпляр класса соответственно в атрибуты x и y
# метод get_distance, который обязательно принимает экземпляр класса Point и возвращает расстояние между двумя точками по теореме Пифагора. В случае, если в данный метод передается не экземпляр класса Point необходимо вывести сообщение "Передана не точка"
# Пример работы с классом Point
#
# p1 = Point()
# p2 = Point()
# p1.set_coordinates(1, 2)
# p2.set_coordinates(4, 6)
# d = p1.get_distance(p2) # вернёт 5.0
# p1.get_distance(10) # Распечатает "Передана не точка"

# class Point:
#     def set_coordinates(self, x, y):
#         self.x = x
#         self.y = y
#
#     def get_distance(self, arg):
#         if isinstance(arg, Point):
#             return ((self.x - arg.x) ** 2 + (self.y - arg.y) ** 2) ** 0.5
#         else:
#             print(f'Передана не точка')
#
# x = Point()
# y = Point()
# x.set_coordinates(1, 2)
# y.set_coordinates(4, 6)
# d = x.get_distance(y) # вернёт 5.0
# # x.get_distance(10) # Распечатает "Передана не точка"
# # Теорема Пифагора по 2 точкам (если кому поможет):
# # s = ((x2-x1)**2+(y2-y1)**2)**0.5

# --------------------------------------
# # Создайте класс Laptop, у которого есть:
# #
# # конструктор __init__, принимающий 3 аргумента: бренд, модель и цену ноутбука. На основании этих аргументов нужно для экземпляра создать атрибуты brand, model, price и также атрибут laptop_name - строковое значение, вида "<brand> <model>"
#
# class Laptop:
#     def __init__(self, brand, model, price):
#         self.brand = brand
#         self.model = model
#         self.price = price
#         self.laptop_name = f'{brand} {model}'
#
#
# laptop1=Laptop('Asus', '18-bdfx', 37000)
# laptop2=Laptop('Samsung', '13-bsdf0xx', 47000)
#
# hp = Laptop('hp', '15-bw0xx', 57000)
# print(hp.price) # выводит 57000
# print(hp.laptop_name) # выводит "hp 15-bw0xx"

# _________________________________________
# Создайте класс SoccerPlayer, у которого есть:
#
# конструктор __init__, принимающий 2 аргумента: name, surname. Также во время инициализации необходимо создать 2 атрибута экземпляра: goals и assists - общее количество голов и передач игрока, изначально оба значения должны быть 0
# метод score, который принимает количество голов, забитых игроком, по умолчанию данное значение равно единице. Метод должен увеличить общее количество забитых голов игрока на переданное значение;
# метод make_assist, который принимает количество передач, сделанных игроком за матч, по умолчанию данное значение равно единице. Метод должен увеличить общее количество сделанных передач игроком на переданное значение;
# метод statistics, который вывод на экран статистику игрока в виде:
# <Фамилия> <Имя> - голы: <goals>, передачи: <assists>


# class SoccerPlayer:
#     def __init__(self, name, surname, goals=0, assists=0):
#         self.name = name
#         self.surname = surname
#         self.goals = goals
#         self.assists = assists
#
#     def score(self, goals = 1):
#         self.goals += goals
#
#     def make_assist(self, assists = 1):
#         self.assists += assists
#
#     def statistics(self):
#         print(f'{self.name} {self.surname} - голы: {self.goals}, передачи: {self.assists}')
#
#
# leo = SoccerPlayer('Leo', 'Messi')
# leo.score(700)
# leo.make_assist(500)
# leo.statistics() # выводит "Messi Leo - голы: 700, передачи: 500"
# kokorin = SoccerPlayer('Alex', 'Kokorin')
# kokorin.score()
# kokorin.statistics() # выводит "Kokorin Alex - голы: 1, передачи: 0"

# ________________________________
#  Создайте класс Zebra, внутри которого есть метод which_stripe , который поочередно печатает фразы "Полоска белая", "Полоска черная", начиная именно с фразы "Полоска белая"
#
# Пример работы с классом Zebra
#
# z1 = Zebra()
# z1.which_stripe() # печатает "Полоска белая"
# z1.which_stripe() # печатает "Полоска черная"
# z1.which_stripe() # печатает "Полоска белая"
#
# z2 = Zebra()
# z2.which_stripe() # печатает "Полоска белая"
#
#
# class Zebra:
#
#     def __init__(self):
#         self.a = 0
#
#     def which_stripe(self):
#         while True:
#             if self.a == 0:
#                 self.a += 1
#                 print('Полоска белая')
#             else:
#                 self.a -= 1
#                 print('Полоска черная')
#
# z1 = Zebra()
# z1.which_stripe() # печатает "Полоска белая"
# z1.which_stripe() # печатает "Полоска черная"
# z1.which_stripe() # печатает "Полоска белая"
#
# z2 = Zebra()
# z2.which_stripe() # печатает "Полоска белая"

# ___________________________________________
# Создайте класс Person, у которого есть:
#
# конструктор __init__, принимающий 3 аргумента: first_name, last_name, age.
# метод full_name, который возвращает строку в виде "<Фамилия> <Имя>"
# метод is_adult, который возвращает True, если человек достиг 18 лет и False в противном случае;
# p1 = Person('Jimi', 'Hendrix', 55)
# print(p1.full_name())  # выводит "Hendrix Jimi"
# print(p1.is_adult()) # выводит "True"Создайте класс Person, у которого есть:
#
# конструктор __init__, принимающий 3 аргумента: first_name, last_name, age.
# метод full_name, который возвращает строку в виде "<Фамилия> <Имя>"
# метод is_adult, который возвращает True, если человек достиг 18 лет и False в противном случае;
# p1 = Person('Jimi', 'Hendrix', 55)
# print(p1.full_name())  # выводит "Hendrix Jimi"
# print(p1.is_adult()) # выводит "True"

# class Person:
# #     def __init__(self, first_name, last_name, age):
# #         self.first_name = first_name
# #         self.last_name = last_name
# #         self.age = age
# #     def full_name(self):
# #         return f'{self.last_name} {self.first_name}'
# #
# #     def is_adult(self):
# #         if self.age >= 18:
# #             return True
# #         else:
# #             return False
# #
# # p1 = Person('Jimi', 'Hendrix', 55)
# # print(p1.full_name())  # выводит "Hendrix Jimi"
# # print(p1.is_adult()) # выводит "True"
# _______________________________________________

# Создайте класс Dog, у которого есть:
#
# конструктор __init__, принимающий 2 аргумента: name, age.
# метод description, который возвращает строку в виде "<name> is <age> years old"
# метод speak принимающий один аргумент, который возвращает строку вида "<name> says <sound>";
# jack = Dog("Jack", 4)
#
# print(jack.description()) # распечатает 'Jack is 4 years old'
# print(jack.speak("Woof Woof")) # распечатает 'Jack says Woof Woof'
# print(jack.speak("Bow Wow")) # распечатает 'Jack says Bow Wow'
#
#
# class Dog:
#    def __init__(self, name, age):
#        self.name = name
#        self.age = age
#
#    def description(self):
#        return f"{self.name} is {self.age} years old"
#
#    def speak(self, sound):
#        return f"{self.name} says {sound}"
#
# jack = Dog('Jack', 4)
# print(jack.description())
# print(jack.speak("Woof Woof"))
# print(jack.speak("Bow Wow"))

# __________________________________________
# Ваша задача реализовать класс Stack, у которого есть:
#
# метод __init__  создаёт новый пустой стек. Параметры данный метод не принимает. Создает атрибут экземпляра values, где будут в дальнейшем хранятся элементы стека в виде списка (list), изначально при инициализации задайте значение атрибуту values равное пустому списку;
# метод push(item) добавляет новый элемент на вершину стека, метод ничего не возвращает.
# метод pop() удаляет верхний элемент из стека. Параметры не требуются, метод возвращает элемент. Стек изменяется. Если пытаемся удалить элемент из пустого списка, необходимо вывести сообщение "Empty Stack";
# метод peek() возвращает верхний элемент стека, но не удаляет его. Параметры не требуются, стек не модифицируется. Если элементов в стеке нет, распечатайте сообщение "Empty Stack", верните None после этого;
# метод is_empty() проверяет стек на пустоту. Параметры не требуются, возвращает булево значение.
# метод size() возвращает количество элементов в стеке. Параметры не требуются, тип результата - целое число.
# class Stack:
#     def __init__(self):
#         self.values = []
#
#     def push(self, item):
#         self.values.append(item)
#
#     def pop(self):
#         return self.values.pop() if self.values else print("Empty Stack")
#
#     def peek(self):
#         return self.values[-1] if self.values else print("Empty Stack")
#
#     def is_empty(self):
#         return len(self.values) == 0
#
#     def size(self):
#         return len(self.values)
#
# s = Stack()
# s.peek()  # распечатает 'Empty Stack'
# print(s.is_empty())  # распечатает True
# s.push('cat')  # кладем элемент 'cat' на вершину стека
# s.push('dog')  # кладем элемент 'dog' на вершину стека
# print(s.peek())  # распечатает 'dog'
# s.push(True)  # кладем элемент True на вершину стека
# print(s.size())  # распечатает 3
# print(s.is_empty())  # распечатает False
# s.push(777)  # кладем элемент 777 на вершину стека
# print(s.pop())  # удаляем элемент 777 с вершины стека и печатаем его
# print(s.pop())  # удаляем элемент True с вершины стека и печатаем его
# print(s.size())  # распечатает 2
# _____________________________________
# Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
#
# y больше или равно x
# y делится нацело на 5
#
#
# def closest_mod_5(x):
#     while True:
#        if x % 5 == 0 and x >=0:
#            return x
#        else:
#            x +=1
#
# print(closest_mod_5(7))

# __________________________________________
#  Создайте класс UserMail, у которого есть:
#
# конструктор __init__, принимающий 2 аргумента: логин и почтовый адрес. Их необходимо сохранить в экземпляр как атрибуты login и __email (обратите внимание, защищенный атрибут)
# метод геттер get_email, которое возвращает защищенный атрибут __email ;
# метод сеттер set_email, которое принимает в виде строки новую почту. Метод должен проверять, что в новой почте есть только один символ @ и после нее есть точка. Если данные условия выполняются, новая почта сохраняется в атрибут __email, в противном случае выведите сообщение "Ошибочная почта";
# создайте свойство email, у которого геттером будет метод get_email, а сеттером - метод set_email

#
# class UserMail:
#     def __init__(self,  login, __email ):
#         self.login = login
#         self.__email = __email
#
#     def get_email(self):
#         return self.__email
#
#     def set_email(self, __email_new):
#         if __email_new.count("@") == 1 and "." in __email_new[__email_new.index("@") + 1:]:
#             self.__email = __email_new
#         else:
#             print("Ошибочная почта")
#
#     email = property(fget = get_email, fset = set_email)
#
# k = UserMail('belosnezhka', 'prince@wait.you')
# print(k.email)  # prince@wait.you
# k.email = [1, 2, 3] # Ошибочная почта
# k.email = 'prince@still@.wait'  # Ошибочная почта
# k.email = 'prince@still.wait'
# print(k.email)  # prince@still.wait

# ________________________________
# Используя замыкания функций, определите вложенную функцию, которая бы увеличивала значение переданного параметра на 5 и возвращала бы вычисленный результат. При этом внешняя функция должна иметь следующую сигнатуру:
#
# def counter_add(): ...
#
# Вызовите функцию counter_add и результат ее работы присвойте переменной с именем cnt. Вызовите внутреннюю функцию через переменную cnt со значением k, введенным с клавиатуры:
#
# k = int(input())
#
# Выведите результат на экран.
#
#
# def counter_add(cnt):
#     def in_add():
#
#         return cnt +5
#     return in_add
#
#
# k = int(input())
# n = counter_add(k)
# print(n())
# _____________________________
# Подвиг 2. Используя замыкания функций, объявите внутреннюю функцию, которая увеличивает значение своего аргумента на некоторую величину n - параметр внешней функции с сигнатурой:
#
# def counter_add(n): ...
#
# Вызовите внешнюю функцию counter_add со значением аргумента 2 и результат присвойте переменной cnt. Вызовите внутреннюю функцию через переменную cnt со значением k, введенным с клавиатуры:
#
# k = int(input())
#
# Выведите результат на экран.
#
# Sample Input:
#
# 5
# Sample Output:
#
# 7
# def counter_add(a):
#     def incounter(cnt = 2):
#         cnt = cnt + a
#         return cnt
#     return incounter
#
#
#
# k = int(input())
# n = counter_add(k)
# print(n())
# ///
# _______________
# Подвиг 3. Используя замыкания функций, объявите внутреннюю функцию, которая заключает в тег h1 строку s (s - строка, параметр внутренней функции). Далее, на вход программы поступает строка и ее нужно поместить в тег h1 с помощью реализованного замыкания. Результат выведите на экран.
#
# P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>
#
# Sample Input:
#
# Balakirev
# Sample Output:
#
# <h1>Balakirev</h1>
#
# def one1(s):
#     def two2():
#        return f"<h1>{s}</h1>"
#
#     return two2()
#
# print(one1(input()))

# ____________________________________
# Подвиг 4. Используя замыкания функций, объявите внутреннюю функцию, которая заключает строку s (s - строка, параметр внутренней функции) в произвольный тег, содержащийся в переменной tag - параметре внешней функции.
#
# Далее, на вход программы поступают две строки: первая с тегом, вторая с некоторым содержимым. Вторую строку нужно поместить в тег из первой строки с помощью реализованного замыкания. Результат выведите на экран.
#
# P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>
#
#
# def counter_add(tag):
#     def counter_in(s):
#         return f'<{tag}>{s}</{tag}>'
#     return counter_in
#
# tag = input()
# s = input()
#
# print(counter_add(tag)(s))
# ______________________________________________
# Подвиг 5. Используя замыкания функций, объявите внутреннюю функцию, которая преобразует строку из списка целых чисел, записанных через пробел, либо в список, либо в кортеж. Тип коллекции определяется параметром tp внешней функции. Если tp = 'list', то используется список, иначе (при другом значении) - кортеж.
#
# Далее, на вход программы поступают две строки: первая - это значение для параметра tp; вторая - список целых чисел, записанных через пробел. С помощью реализованного замыкания преобразовать эти данные в соответствующую коллекцию. Результат вывести на экран командой (lst - ссылка на коллекцию):
#
# print(lst)

# def counter_add(tp):
#     def counter_in(s):
#         if tp == "list":
#             return list(s)
#         else:
#             return tuple(s)
#     return counter_in
#
# tp = input()
# s = list(map(int, input().split()))
# print(counter_add(tp)(s))

# ___________________________
# def func_show (func):
#     def wraper (*args, **kwargs):
#         print(f"Площадь прямоугольника: {s}")
#     return wraper()
#
#
# @func_show
# def get_sq(width, height):
#     s = 0
#     s = width * height
#     return s
#
# n, m  = map(int, input().split())
# res = get_sq(n,m)
# print(res)
# _________________________________
# Подвиг 1. Объявите функцию с именем get_sq, которая вычисляет площадь прямоугольника по двум параметрам: width и height - ширина и высота прямоугольника. И возвращает результат (сама ничего на экран не выводит). То есть, функция имеет сигнатуру:
#
# def get_sq(width, height): ...
#
# Определите декоратор func_show для этой функции, который отображает результат на экране в виде строки (без кавычек):
#
# "Площадь прямоугольника: <значение>"
#
# Вызывать функцию и декоратор не нужно, только объявить. Применять декоратор к функции также не нужно.
#
# Sample Input:
#
# 8 11
#
#
# def func_show(func):
#     def wrapper(*args):
#         func(*args)
#         print(f'Площадь прямоугольника: {func(*args)}')
#
#     return wrapper
#
# def get_sq(width, height):
#     s = width * height
#     return s
#
# # w, h = map(int, input().split())
#
# # get_sq = func_show(get_sq)
# get_sq(8, 11)
# _________________________________________________
#
# Подвиг 3. На вход программы поступает строка из целых чисел, записанных через пробел. Напишите функцию get_list, которая преобразовывает эту строку в список из целых чисел и возвращает его. Определите декоратор для этой функции, который сортирует список чисел по возрастанию. Результат сортировки должен возвращаться при вызове декоратора.
#
# Вызовите декорированную функцию get_list и отобразите полученный отсортированный список lst командой:
#
# print(*lst)
#
# Sample Input:
#
# 8 11 -5 4 3 10
# Sample Output:
#
# -5 3 4 8 10 11
#
# def show_menu(func):
#     def wrapper(*args):
#         func()
#     return wrapper
#
# def get_menu(s):
#     a = []
#     b = 1
#     for i in s.split():
#         a.append(f'{b}. {i}')
#         b +=1
#     print(*a, sep='\n')
#
#
# # n = input()
# # print(get_menu(n))
# # get_sq = func_show(get_sq)
# # get_menu(n)
# get_menu('Главная Добавить Удалить Выйти')
#
# _____________________________________________
# Подвиг 3. На вход программы поступает строка из целых чисел, записанных через пробел. Напишите функцию get_list, которая преобразовывает эту строку в список из целых чисел и возвращает его. Определите декоратор для этой функции, который сортирует список чисел по возрастанию. Результат сортировки должен возвращаться при вызове декоратора.
#
# Вызовите декорированную функцию get_list и отобразите полученный отсортированный список lst командой:
#
# print(*lst)
#
# Sample Input:
#
# 8 11 -5 4 3 10
# Sample Output:
#
# -5 3 4 8 10 11

# def func_show(func):
#     def wrapper(*args):
#         func(*args)
#         print(*func)
#
#     return wrapper
#
# def get_sq(lst):
#     # l = sorted(n, key=None)
#     print(*sorted(n, key=None))
#     return ""
#
# n = list(map(int, input().split()))
# # print(*(sorted(n, key=None)))
# # get_sq = func_show(get_sq)
# print(get_sq(n))

#
# ________________________________________
#
#
# class Money:
#     def __init__(self,  dollars, cents):
#         self.dollars = dollars
#         self.cents = cents
#
#
#     def total_cents(self):
#         self.dollars = dollars
#         self.cents = cents
#
#     def get_dollars(self):
#         return self.dollars
#
#     def set_dollars(self, num):
#         if isinstance(num, int) and num >= 0:
#            self.total_dollars = self.total_dollars + num
#         else:
#             print("Error dollars")
#
#     def get_cents(self):
#         return self.cents
#
#     def set_cents(self, num):
#         if 100 < num > 0:
#            self.total_cents = self.total_cents + num
#         else:
#             print("Error cents")
#
#     def __str__(self,dollars, cents, total_cents ):
#         print(f'Ваше состояние составляет {self.dollars} долларов {self.cents} центов')
#
#
# Bill = Money(101, 99)
# print(Bill)  # Ваше состояние составляет 101 долларов 99 центов
# print(Bill.dollars, Bill.cents)  # 101 99
# Bill.dollars = 666
# print(Bill)  # Ваше состояние составляет 666 долларов 99 центов
# Bill.cents = 12
# print(Bill)  # Ваше состояние составляет 666 долларов 12 центов
# ________________________
#
# class Robot:
#
#      population = 0
#
#      def __init__(self, name):
#          self.name = name
#          Robot.population += 1
#          print(f"Робот {self.name} был создан")
#
#      def destroy (self):
#          Robot.population -= 1
#          print(f"Робот {self.name} был уничтожен")
#
#      def say_hello(self):
#          print(f"Робот {self.name} приветствует тебя, особь человеческого рода")
#
#      @classmethod
#      def how_many(cls):
#          print(f"{cls.population}, вот сколько нас еще осталось")
#
# r2 = Robot("R2-D2") # печатает "Робот R2-D2 был создан"
# r2.say_hello() # печатает "Робот R2-D2 приветствует тебя, особь человеческого рода"
# Robot.how_many() # печатает "1, вот сколько нас еще осталось"
# r2.destroy() # печатает "Робот R2-D2 был уничтожен"
# _________________________________________

# Создайте класс Person, у которого есть:
#
# конструктор __init__, принимающий 3 аргумента: name, surname, gender. Атрибут gender может принимать только 2 значения: "male" и "female", по умолчанию "male". Если в атрибут gender передается любое другое значение, печатать сообщение: "Не знаю, что вы имели ввиду? Пусть это будет мальчик!" и проставить атрибут gender значением "male"
# переопределить метод __str__ следующим образом:
# если объект - мужчина (атрибут gender = "male"), возвращать строку "Гражданин <Фамилия> <Имя>
# если объект - женщина (атрибут gender = "female"), возвращать строку "Гражданка <Фамилия> <Имя>
#
#
#
# class Person:
#     def __init__(self, name, surname, gender = "male" ):
#         self.name = name
#         self.surname = surname
#         if gender == "male" or gender == "female":
#             self.gender = gender
#         else:
#             print("Не знаю, что вы имели ввиду? Пусть это будет мальчик!")
#             self.gender = "male"
#     def __str__(self):
#         if self.gender == "female":
#             return f"Гражданка {self.surname} {self.name}"
#         elif self.gender == "male":
#             return f"Гражданин {self.surname} {self.name}"
#
#
# p1 = Person('Chuck', 'Norris')
# print(p1) # печатает "Гражданин Norris Chuck"
# p2 = Person('Mila', 'Kunis', 'female')
# print(p2) # печатает "Гражданка Kunis Mila"
# p3 = Person('Оби-Ван', 'Кеноби', True)# печатает "Не знаю, что вы имели ввиду? Пусть это будет мальчик!"
# print(p3) # печатает "Гражданин Кеноби Оби-Ван"

# ____________________________
#   Создайте класс Vector, который хранит в себе вектор целых чисел.  У класса Vector есть:
#
# конструктор __init__, принимающий произвольное количество аргументов. Среди всех переданных аргументов необходимо оставить только целые числа и сохранить их в атрибут values в виде списка;
# переопределить метод __str__ так, чтобы экземпляр класса Vector выводился следующим образом:
# "Вектор(<value1>, <value2>, <value3>, ...)", если вектор не пустой. При этом значения должны быть упорядочены по возрастанию (будьте аккуратнее с пробелами, они стоят только после запятых, см. пример ниже);
# "Пустой вектор", если наш вектор не хранит в себе значения


# class Vector:
#     def __init__(self, *args, **kwargs):
#         values = list(''.join([str(i) for i in args if isinstance(i, int)]))
#         self.values = values
#
#     def __str__(self):
#         if self.values != 0:
#             # result = ', '.join(map(str, sorted(self.values)))
#             # return str(f'Вектор({result})')
#             return f'Вектор{(*sorted(self.values),)}'
#         else:
#             return "Пустой вектор"
#
# v1 = Vector(1,2,3)
# print(v1) # печатает "Вектор(1, 2, 3)"
# v2 = Vector()
# print(v2) # печатает "Пустой вектор"
#
#

# __________________________________________
# args = (4,2,3)
# values = list(', '.join([str(i) for i in args if isinstance(i, int)]))
# result = ', '.join(map(str, sorted(values)))
# print(values)
# print(result)


# args = (4,2,3)
# values = sorted([x for x in args if isinstance(x, int)])
# values = sorted(list(''.join([str(i) for i in args if isinstance(i, int)])))
# print(*sorted(values),)
# print(values)

# ______________________________________________

# class Vector:
#     def __init__(self, *args, **kwargs):
#         values = sorted([x for x in args if isinstance(x, int)])
#         self.values = values
#
#     def __str__(self):
#         if self.values != 0:
#             return f'Вектор{(*(self.values),)}'
#         else:
#             return "Пустой вектор"
#
#     def __add__(self, other):
#         if isinstance(other, Vector):
#             new = []
#             if len(self.values) == len(other):
#                 new =[self.values[i] + other[i] for i in range(len(self.values))]
#                 return Vector(*[i for i in new])
#             else:
#                 print('Сложение векторов разной длины недопустимо')
#             if isinstance(other, int):
#                 for i in range(len(self.values)):
#                     new.append(self.values[i] + other)
#                 return Vector(*[i for i in new])
#             if not isinstance(other, (Vector, int)):
#                 print(f'Вектор нельзя сложить с {other}')
#
#
# v1 = Vector(1,2,3)
# print(v1) # печатает "Вектор(1, 2, 3)"
#
# v2 = Vector(3,4,5)
# print(v2) # печатает "Вектор(3, 4, 5)"
# v3 = v1 + v2
# print(v3) # печатает "Вектор(4, 6, 8)"
# v4 = v3 + 5
# _________________________________________
# И так, ваша задача реализовать класс ChessPlayer, который состоит из:
#
# метода инициализации, принимающего аргументы name, surname, rating;
# магического  метода __eq__, который будет позволять сравнивать экземпляры класса ChessPlayer с числами и другими экземплярами этого класса. Если сравнение происходит с целым числом и атрибут rating с ним совпадает, то необходимо вернуть True, в противном случае - False. Если же сравнение идет с другим шахматистом(экземпляром класса ChessPlayer)  и значения атрибутов rating равны, то возвращается True, в противном случае - False. А если же сравнивается с другим типом данных, верните ‘Невозможно выполнить сравнение’;
# магического  метода __gt__. Если сравнение происходит с целым числом и атрибут rating больше его, необходимо вернуть значение True, в противном же случае - False. Если сравнение происходит с другим шахматистом(экземпляром класса ChessPlayer) и атрибут rating у нашего экземпляра больше, то верните True, в противном случае - False. В случае если сравнение идет с остальными типами данных, верните ‘Невозможно выполнить сравнение’
# магического  метода __lt__. Если сравнение происходит с целым числом и атрибут rating меньше его, необходимо вернуть значение True, в противном же случае - False. Если сравнение происходит с другим шахматистом(экземпляром класса ChessPlayer) и атрибут rating у нашего экземпляра меньше, то верните True, в противном случае - False. В случае если сравнение идет с остальными типами данных, верните ‘Невозможно выполнить сравнение’.

# class ChessPlayer:
#     def __init__(self, name, surname, rating):
#         self.name = name
#         self.surname = surname
#         self.rating = rating
#
#     def __eq__(self, other):
#         if isinstance(other, (int, float)):
#             return self.rating == other
#         elif isinstance(other, ChessPlayer):
#             return self.rating == other.rating
#         else:
#             return "Невозможно выполнить сравнение"
#
#     def __gt__(self, other):
#         if isinstance(other, (int, float)):
#             return self.rating > other
#         elif isinstance(other, ChessPlayer):
#             return self.rating > other.rating
#         else:
#             return "Невозможно выполнить сравнение"
#
#     def __lt__(self, other):
#         if isinstance(other, (int, float)):
#             return self.rating < other
#         elif isinstance(other, ChessPlayer):
#             return self.rating < other.rating
#         else:
#             return "Невозможно выполнить сравнение"
#
# class ChessPlayer:
#     def __init__(self, name, surname, rating):
#         self.name = name
#         self.surname = surname
#         self.rating = rating
#
#     def __eq__(self, other):
#         if isinstance(other, (int, float)):
#             return self.rating == other
#         elif isinstance(other, ChessPlayer):
#             return self.rating == other.rating
#         else:
#             return "Невозможно выполнить сравнение"
#
#     def __gt__(self, other):
#         if isinstance(other, (int, float)):
#             return self.rating > other
#         elif isinstance(other, ChessPlayer):
#             return self.rating > other.rating
#         else:
#             return "Невозможно выполнить сравнение"
#
#     def __lt__(self, other):
#         if isinstance(other, (int, float)):
#             return self.rating < other
#         elif isinstance(other, ChessPlayer):
#             return self.rating < other.rating
#         else:
#             return "Невозможно выполнить сравнение"
#
#
# magnus = ChessPlayer('Carlsen', 'Magnus', 2847)
# ian = ChessPlayer('Ian', 'Nepomniachtchi', 2789)
# print(magnus == 4000) # False
# print(ian == 2789) # True
# print(magnus == ian) # False
# print(magnus > ian) # True
# print(magnus < ian) # False
# print(magnus < [1, 2]) # печатает "Невозможно выполнить сравнениe"
#
# _____________________________

# Создайте класс City, у которого есть:
#
# конструктор __init__, принимающий единственный аргумент - название города. Вам необходимо сохранить его в качестве атрибута экземпляра name, причем вам нужно преобразовать переданное имя города таким образом, чтобы первая буква каждого слова была заглавной, а остальные оказались строчными (пример "new york" - > "New York")
# переопределить метод __str__ таким образом, чтобы он возвращал имя города
# переопределить метод __bool__ так, чтобы он возвращал False ,если название города заканчивается на любую гласную букву латинского алфавита (a, e, i, o, u), в противном случае True
# class City:
#     def __init__(self, name):
#         self.name = name.title()
#
#     def __str__(self):
#        return self.name
#
#     def __bool__(self):
#         return self.name[-1] not in 'aeiou'
#
#
# p1 = City('new york')
# print(p1)  # печатает "New York"
# print(bool(p1))  # печатает "True"
# p2 = City('SaN frANCISco')
# print(p2)  # печатает "San Francisco"
# print(p2 == True)  # печатает "False"
#
# ________________________________-

# class Quadrilateral:
#     def __init__(self, *args):
#         if len(args) == 1:
#             self.width = args[0]
#             self.height = args[0]
#         else:
#             self.width = args[0]
#             self.height = args[1]
#
#     def __str__(self):
#         if self.width == self.height:
#            return f'Куб размером {self.width}х{self.height}'
#         else:
#             return f'Прямоугольник размером {self.width}х{self.height}'
#
# q1 = Quadrilateral(10)
# print(q1)  # печатает "Куб размером 10х10"
# print(bool(q1))  # печатает "True"
# q2 = Quadrilateral(3, 5)
# print(q2)  # печатает "Прямоугольник размером 3х5"
# print(q2 == True)  # печатает "False"

# _____________________________________

#
# class Vehicle:
#     def __init__(self):
#         pass
#
# class Car(Vehicle):
#     def __init__(self):
#         pass
#
# class RaceCar(Car):
#        pass
#
# class Plane(Vehicle):
#     def __init__(self):
#         pass
#
# class Boat(Vehicle):
#     def __init__(self):
#         pass
#
#
# print(RaceCar.mro())

# _____________________________
# Создайте класс NewInt, который унаследован от целого типа int, то есть мы будем унаследовать поведение целых чисел и значит экземплярам нашего класса будут поддерживать те же операции, что и целые числа.
#
# Дополнительно в классе NewInt нужно создать:
#
# метод repeat, который принимает одно целое положительное число n (по умолчанию равное 2), обозначающее сколько раз нужно продублировать данное число. Метод repeat должен возвращать новое число, продублированное n раз (см пример ниже);
# метод to_bin, который возвращает двоичное представление числа в виде числа (может пригодиться функция bin)

# class Newlnt(int):
#
#     def repeat(self, n = 2):
#         return int(str(self)*n)
#
#     def to_bin(self):
#         return int(bin(self)[2:])
#
#
# p = Newlnt(54)
# print(p.repeat(5))

# _________________________________

class Transport:

class Car(Transport):


class Boat(Transport):
class Transport: